#!/usr/bin/env node

var ArgumentParser = require('argparse').ArgumentParser;
var Bundler = require('../');
var Checker = require('../checker.js');
var Fs = require('fs');
var Mkdirp = require('mkdirp');
var Package = require('../package.json');
var Path = require('path');


var parser = new ArgumentParser({
    description: 'Intelligently bundle your code for https://webtask.io',
    epilog: 'See https://webtask.io/docs for more information',
    prog: Object.keys(Package.bin)[0],
    version: Package.version,
});

parser.addArgument(
    ['--loose'],
    {
        help: 'Skip the strict Semver versioning test for required modules',
        action: 'storeTrue',
        defaultValue: false,
        dest: 'loose',
    }
);

parser.addArgument(
    ['-p', '--prod'],
    {
        help: 'Generate a minimized production build',
        action: 'storeTrue',
        defaultValue: false,
        dest: 'prod',
    }
);

parser.addArgument(
    ['-o', '--output'],
    {
        help: 'Write the bundled code to a file instead of stdout',
        type: 'string',
        dest: 'output',
        metavar: '<OUTPUT>'
    }
);

parser.addArgument(
    ['-w', '--watch'],
    {
        help: 'Watch the source file for changes',
        action: 'storeTrue',
        defaultValue: false,
        dest: 'watch',
    }
);

parser.addArgument(
    ['filename'],
    {
        metavar: '<FILENAME>',
        type: String,
        help: 'Entrypoint filename for your webtask code',
        defaultValue: './webtask.js',
    }
);


var subparsers = parser.addSubparsers({
    title: 'modules',
    dest:  'modules'
});

subparsers.addParser('check', {
    help: 'Check the version of each module against webtask.io'
});

subparsers.addParser('sync', {
    help: 'Recreate "package.json" using webtask.io compatible version of each module'
})
.addArgument(
    ['-i'],
    {
        help: 'Ask on every module ',
        action: 'storeTrue',
        dest: 'interactive'
    }
);

var args = parser.parseArgs();

if (args.watch && !args.output) {
    return exitError('An `ouput` path is required when `watch` is enabled', { showHelp: true });
}

if (args.modules === 'check') {
    var $check = Checker.check({
        entry: Path.resolve(process.cwd())
    });
    $check.subscribe(function () {}, onError, onComplete);

    return;
}

if (args.modules === 'sync') {
    var $sync = Checker.sync({
        entry: Path.resolve(process.cwd()),
        interactive: args.interactive
    });

    $sync.subscribe(function () {}, onError, onComplete);

    return;
}

var bundle$ = Bundler.bundle({
    entry: Path.resolve(Path.join(process.cwd(), args.filename)),
    loose: args.loose,
    minify: args.prod,
    watch: args.watch,
});

bundle$.subscribe(onNext, onError, onComplete);

function onNext(build) {
    if (build.stats.errors.length) {
        console.error('Build failed at generation %d with errors:', build.generation);
        console.error(build.stats.errors);
        return;
    }
    
    if (args.output) {
        if (args.watch) {
            console.log('Successfully built code at generation %d', build.generation);
        }

        Mkdirp(Path.dirname(args.output), function (err) {
            if (err) {
                return exitError('Error creating the output directory: ' + err.message);
            }

            Fs.writeFile(args.output, build.code, 'utf8', function (err) {
                if (err) {
                    return exitError('Error writing output to `' + Path.basename(args.output) + '`: ' + err.message);
                }

                console.log('Bundle successfully written to `%s`', args.output);
            });
        });
    } else {
        console.log(build.code);
    }
}

function onError(err) {
    console.error(err.message);
}

function onComplete() {
}

function exitError(message, options) {
    if (!options) options = {};

    var exitCode = typeof options.exitCode === 'undefined'
        ?   1
        :   options.exitCode;

    console.error(message);

    if (options.showHelp) {
        Argv.help();
    }

    process.exit(exitCode);
}
